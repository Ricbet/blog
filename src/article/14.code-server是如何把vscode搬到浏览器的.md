[code-server](https://github.com/cdr/code-server/tree/2.1692-vsc1.39.2) æ˜¯ä¸€ä¸ªå¼€æºçš„åœ¨çº¿ vscode è¿œç«¯è¿è¡ŒæœåŠ¡ï¼Œæœ¬æ–‡ä»æºç è§’åº¦æ¥è§£è¯»ä»–æ˜¯å¦‚ä½•æŠŠ vscode æ¬åˆ°æµè§ˆå™¨è¿è¡Œçš„

> vscode ç‰ˆæœ¬ 1.39.2 </br>
> node ç‰ˆæœ¬ 10.16.0

### å…ˆé¢„çƒ­ä¸€ä¸‹ vscode æ¶æ„

![1.png](../assets/img/14/1.png)

ä½œä¸ºæœ¬åœ°çš„ Electron åº”ç”¨ï¼Œä»–é‡‡ç”¨çš„æ˜¯å¤šè¿›ç¨‹æ¶æ„;

ä¸»è¿›ç¨‹å’Œå¾ˆå¤šå­è¿›ç¨‹ä¹‹é—´è¿›è¡Œ IPC é€šä¿¡æˆ– RPC è¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼Œå…¶ä¸­æ’ä»¶ç³»ç»Ÿä¹Ÿä½œä¸ºäº†ä¸€ä¸ªè¿›ç¨‹ï¼Œæ‰€æœ‰çš„æ’ä»¶éƒ½ä¼šåœ¨è¿™ä¸ªè¿›ç¨‹ä¸‹è¿è¡Œï¼ŒåŒ…æ‹¬è¯­è¨€æœåŠ¡åè®®ç­‰;

debug åè®®ä¸å…¶ä»–è¿›ç¨‹ä¸åŒï¼Œæ¯æ¬¡æ‰§è¡Œ debug éƒ½ä¼šæ–°å¼€ä¸€ä¸ªå­è¿›ç¨‹;

å…¶ä¸­è¾ƒä¸ºå¸¸è§çš„æ–‡ä»¶è¯»å†™éƒ½æ˜¯åœ¨ main ä¸»è¿›ç¨‹ä¸­å®Œæˆ;

### coder å¼€å‘æµç¨‹

åœ¨ coder-server çš„ README é‡Œæœ‰å¼€å‘æµç¨‹æ­¥éª¤ï¼Œå¤§æŠµä¸Šåˆ†ä¸º

```shell
git clone https://github.com/microsoft/vscode
cd vscode
git checkout ${vscodeVersion} # See travis.yml for the version to use.
yarn
git clone https://github.com/cdr/code-server src/vs/server
cd src/vs/server
yarn
yarn patch:apply
yarn watch
# Wait for the initial compilation to complete (it will say "Finished compilation").
# Run the next command in another shell.
yarn start
# Visit http://localhost:8080
```

1. å…ˆ `clone` vscode é¡¹ç›®å¹¶åˆ‡æ¢åˆ°æŸå›ºå®šç‰ˆæœ¬
2. æŠŠè‡ªå·± `clone` åˆ° `src/vs/server` ç›®å½•ä¸‹
3. æŠŠé­”æ”¹çš„éƒ¨åˆ†é€šè¿‡è¡¥ä¸ `patch` æ‰“è¿› vscodeï¼Œæ‰§è¡Œ `watch` å°† vscode é¡¹ç›®é‡Œçš„ ts ä»£ç ç¼–è¯‘æˆå¯æ‰§è¡Œçš„ js æ–‡ä»¶å¹¶è¾“å‡ºåˆ° out ç›®å½•
4. start å…¶å®å°±æ˜¯ç”¨ node è·‘ out/vs/server/main.js æ–‡ä»¶

æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è®¤ä¸ºä»–å®Œå…¨æ˜¯å……å½“äº† vscode çš„ server ç«¯ï¼Œä¸ºå…¶ web ç‰ˆæä¾›æ”¯æŒèƒ½åŠ›ï¼Œé‡ç‚¹å°±æ˜¯åœ¨ patch è¡¥ä¸éƒ¨åˆ†

### ç›®å½•

```tree
scripts
â”œâ”€â”€ build.ts                        // ä¸»è¦çš„ build è„šæœ¬æ–‡ä»¶ï¼Œåˆ†ä¸º buildã€binaryã€package å’Œ ensure-in-vscode å››ç§ task
â”œâ”€â”€ ci.bash                         // ç”¨äºè·‘ CI æ„å»ºæµç¨‹ï¼Œåˆ†ä¸º docker-build å’Œ local-build
â”œâ”€â”€ ci.dockerfile
â”œâ”€â”€ optimize.js
â”œâ”€â”€ package.json
â”œâ”€â”€ product.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ vscode.patch                    // é’ˆå¯¹ vscode 1.39.2 ç‰ˆæœ¬æ‰“çš„ git patch æ–‡ä»¶
src
â”œâ”€â”€ browser                         // ä¸»è¦æ˜¯ client ç«¯çš„å®ç°
â”‚   â”œâ”€â”€ api.ts                      // vscode å®¢æˆ·ç«¯çš„ api å®ç°
â”‚   â”œâ”€â”€ client.ts                   // å®¢æˆ·ç«¯åˆå§‹åŒ–æ‰§è¡Œ
â”‚   â”œâ”€â”€ extHostNodeProxy.ts         // æ’ä»¶ä»£ç†ï¼Œé€šè¿‡è¡¥ä¸æ‰“åœ¨äº† src/vs/workbench/services/extensions/worker/extHost.services.ts ç›®å½•ä½œä¸ºå•ä¾‹æœåŠ¡ï¼Œè¿›è¡Œ rpc è¿œç¨‹è¿‡ç¨‹è°ƒç”¨
â”‚   â”œâ”€â”€ login.html                  // ç™»é™†æˆæƒ
â”‚   â”œâ”€â”€ mainThreadNodeProxy.ts      // ä¸»çº¿ç¨‹ä»£ç†
â”‚   â”œâ”€â”€ upload.ts                   // ä¸Šè½½æœåŠ¡ï¼Œæ‹–åŠ¨æ–‡ä»¶åœ¨æ–‡ä»¶æ ‘å°±æ‰§è¡Œè¯¥æœåŠ¡
â”‚   â”œâ”€â”€ workbench-build.html
â”‚   â”œâ”€â”€ workbench.html              // å…¥å£ html æ–‡ä»¶
â”‚   â””â”€â”€ worker.ts                   // å¤å†™ src/vs/workbench/api/worker/extHostExtensionService.ts ç›®å½•ä¸‹ _loadCommonJSModule æ–¹æ³•ï¼Œå…¶ä¸­å…³é”®ç”¨åˆ° coder è‡ªå·±å°è£…çš„ node-browser å’Œ requirefsï¼Œä¸ºæµè§ˆå™¨æä¾›è¯¸å¦‚ fsã€netã€require çš„èƒ½åŠ›
â”œâ”€â”€ common                          // server ç«¯å’Œ client ç«¯éƒ½å¯ä½¿ç”¨çš„æœåŠ¡
â”‚   â”œâ”€â”€ nodeProxy.ts                // ä»£ç†éš§é“æœåŠ¡
â”‚   â”œâ”€â”€ telemetry.ts                // é¥æµ‹éš§é“æœåŠ¡
â”‚   â””â”€â”€ util.ts
â”œâ”€â”€ media
â”‚   â”œâ”€â”€ code-server.png
â”‚   â”œâ”€â”€ favicon.ico
â”‚   â”œâ”€â”€ login.css
â”‚   â””â”€â”€ manifest.json
â””â”€â”€ node                            // æœåŠ¡ç«¯ server å®ç°
    â”œâ”€â”€ channel.ts                  // ä¸»è¦
    â”œâ”€â”€ cli.ts
    â”œâ”€â”€ connection.ts               // ä¸»è¦ç”¨äº ipc é€šé“è¿æ¥
    â”œâ”€â”€ insights.ts
    â”œâ”€â”€ ipc.ts
    â”œâ”€â”€ marketplace.ts
    â”œâ”€â”€ nls.ts
    â”œâ”€â”€ protocol.ts                 // ä¸»è¦æ˜¯ websocket çš„åè®®
    â”œâ”€â”€ server.ts
    â”œâ”€â”€ update.ts
    â”œâ”€â”€ uriTransformer.js
    â””â”€â”€ util.ts
typings
â”œâ”€â”€ api.d.ts    
â”œâ”€â”€ httpolyglot.d.ts
â””â”€â”€ package.json
```

### å¯åŠ¨é¡ºåº

åœ¨ server ç›®å½•ä¸‹æ‰§è¡Œ start å‘½ä»¤å…¶å®å°±æ˜¯ç”¨ node è·‘ `out/vs/server/main.js` æ–‡ä»¶

main æ–‡ä»¶æ ¸å¿ƒå°±ä¸€è¡Œ

> require("../../bootstrap-amd").load("vs/server/src/node/cli");

é€šè¿‡ amd æ¨¡å—åŠ è½½ cli æ–‡ä»¶ï¼Œè€Œè¿™ä¸ª cli æ–‡ä»¶å°±æ˜¯ä½äº server/node/cli;

è¯¥æ–‡ä»¶æ‰§è¡Œ <span id="main">main</span> å‡½æ•°
```typescript
const main = async(): Promise<boolean | void | void[]> => {
	const args = getArgs();
	if (process.env.LAUNCH_VSCODE) {
		await ipcMain.handshake();
		return startVscode(args);
	}
	return startCli(args) || new WrapperProcess(args).start();
};
```

è¿™ä¸€æ­¥å¼€å§‹å…¶å® process.env.LAUNCH_VSCODE ç¯å¢ƒå˜é‡åˆå§‹ä¸ºç©ºï¼ŒstartCli å‡½æ•°å…¶å®é‡Œé¢ä¹Ÿæ˜¯æ ¹æ®ç¯å¢ƒå‚æ•°åšä¸€äº›åˆ¤æ–­ï¼Œä½†åˆå§‹éƒ½æ˜¯è¿”å› falseï¼Œå…³é”®æ˜¯è¿™ä¸ª `WrapperProcess`;

å®ä¾‹åŒ– `WrapperProcess` çš„æ—¶å€™ä¾¿å¼€å§‹è¿›è¡Œ ipc çš„ `onMessage` ç›‘å¬ï¼Œç”¨äºè¿›ç¨‹ä¹‹é—´çš„é€šä¿¡ï¼Œå®Œäº†ä¹‹åæ‰§è¡Œ start å‡½æ•°

```typescript
if (!this.started) {
    const child = this.spawn();
    this.started = ipcMain.handshake(child).then(() => {
        child.once("exit", (code) => exit(code!));
    });
    this.process = child;
}
return this.started;
```

é€šè¿‡ spawn åˆ›å»ºäº†å­è¿›ç¨‹å¹¶è¿›å…¥ ipc çš„æ¡æ‰‹é˜¶æ®µï¼Œæ­¤æ—¶æŠŠå½“å‰è¿›ç¨‹æ›¿æ¢åˆ°äº†ä¸»è¿›ç¨‹, è€Œå…¶ä¸­ spawn åšäº†ä»¥ä¸‹äº‹æƒ…

```typescript
//...
const isBinary = (global as any).NBIN_LOADED;
return cp.spawn(process.argv[0], process.argv.slice(isBinary ? 2 : 1), {
    env: {
        ...process.env,
        LAUNCH_VSCODE: "true",
        NBIN_BYPASS: undefined,
        VSCODE_PARENT_PID: process.pid.toString(),
        NODE_OPTIONS: nodeOptions,
    },
    stdio: ["inherit", "inherit", "inherit", "ipc"],
});
```

> NBIN_LOADED ç¯å¢ƒå…¶å®æ˜¯ coder è‡ªå®šä¹‰çš„ï¼Œ[nbin](https://github.com/cdr/nbin) ä¸»è¦æ˜¯é€šè¿‡ç»™ node çš„ fs æ¨¡å—æ‰“è¡¥ä¸ä¸€é¡¿é­”æ”¹è¾¾åˆ°å¢å¼ºäºŒè¿›åˆ¶ç¼–è¯‘çš„è¿‡ç¨‹ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºå•¥ä¼šå¯¹ node ç‰ˆæœ¬å…·æœ‰å¼ºçº¦æŸæ€§çš„åŸå› ï¼ˆéªšã€‚ã€‚ã€‚

ä½¿ç”¨å½“å‰çš„æ‰€æœ‰å‚æ•°é‡æ–°åˆ›å»ºäº†ä¸€ä¸ªå­è¿›ç¨‹å¹¶è¿”å›ï¼Œå…¶ä¸­ stdio æŒ‡å®šäº† ipc é€šé“ï¼ŒLAUNCH_VSCODE ç¯å¢ƒå˜é‡ä¹Ÿè®¾ç½®ä¸ºäº† trueï¼Œæ­¤æ—¶ `main` å‡½æ•°è¢«`é‡æ–°æ‰§è¡Œ`äº†;

å›åˆ° <a href="#main">main</a> è¿™é‡Œ, æ­¤æ—¶ç›´æ¥ç­‰å¾… ipc æ¡æ‰‹ä¹‹åè¿è¡Œ startVscode;

```typescript
//...

const server = new MainServer({
    ...options,
    port: typeof args.port !== "undefined" ? parseInt(args.port, 10) : 8080,
    socket: args.socket,
}, args);

const [serverAddress, /* ignore */] = await Promise.all([
    server.listen(),
    unpackExecutables(),
]);

//...
```

å¯ä»¥æ€»ç»“ä¸ºï¼Œcli å…¶å®å°±æ˜¯å»ºç«‹ ipc é€šé“å¹¶é¢„å¤„ç†ä¸€å¤§å †å‚æ•°ä»è€Œå¯åŠ¨ server çš„è¿‡ç¨‹;

### Server ç«¯

æ¥åˆ° server ç«¯çš„ MainServer å‡½æ•°ï¼Œå®ƒç»§æ‰¿äº†æŠ½è±¡ç±» Serverï¼Œå¹¶åœ¨æ„é€ å‡½æ•°é‡Œå¯åŠ¨ http æœåŠ¡

```typescript
public constructor(options: ServerOptions) {
    this.options = {
        host: options.auth === "password" && options.cert ? "0.0.0.0" : "localhost",
        ...options,
        basePath: options.basePath ? options.basePath.replace(/\/+$/, "") : "",
        password: options.password ? hash(options.password) : undefined,
    };
    this.protocol = this.options.cert ? "https" : "http";
    if (this.protocol === "https") {
        const httpolyglot = localRequire<typeof import("httpolyglot")>("httpolyglot/lib/index");
        this.server = httpolyglot.createServer({
            cert: this.options.cert && fs.readFileSync(this.options.cert),
            key: this.options.certKey && fs.readFileSync(this.options.certKey),
        }, this.onRequest);
    } else {
        this.server = http.createServer(this.onRequest);
    }
}
```

å…¶ä¸­ cert å‚æ•°åšäº†è‡ªç­¾åè¯ä¹¦å¤„ç†ï¼Œæˆ‘çŒœæµ‹æ˜¯ä¸ºäº†å®‰å…¨è€ƒè™‘å§ã€‚ã€‚

onRequest æ–¹æ³•é‡Œå¯¹è¯·æ±‚å¤´åšäº†é¢„å¤„ç†

```typescript
//...
const payload = await this.preHandleRequest(request, parsedUrl);
//...
```

preHandleRequest æ–¹æ³•é‡Œå¯¹è¯·æ±‚çš„è·¯å¾„åšäº†ä¸€é€šæ‹¦æˆªå¤„ç†ï¼Œå…¶ä¸­æœ‰ä¸€æ®µ

```typescript
// Allow for a versioned static endpoint. This lets us cache every static
// resource underneath the path based on the version without any work and
// without adding query parameters which have their own issues.
// REVIEW: Discuss whether this is the best option; this is sort of a quick
// hack almost to get caching in the meantime but it does work pretty well.
if (/^\/static-/.test(base)) {
    base = "/static";
}
```

é€šè¿‡æ­£åˆ™åŒ¹é…æ‰€æœ‰è·¯å¾„é‡Œå¼€å¤´å«æœ‰ `static-` çš„æ–‡ä»¶å°† base è·¯å¾„é‡ç½®ä¸º /static ï¼Œä¸ºäº†åé¢åšç¼“å­˜å¤„ç†

```typescript
//...
case "/static":
    const response = await this.getResource(this.rootPath, requestPath);
    response.cache = true;
    return response;
//...
```

å…¶ä¸­ getResource å°±æ˜¯ç›´æ¥è¯»æ–‡ä»¶å†…å®¹å¹¶è¿”å›

```typescript
protected async getResource(...parts: string[]): Promise<Response> {
    const filePath = this.ensureAuthorizedFilePath(...parts);
    return { content: await util.promisify(fs.readFile)(filePath), filePath };
}
```

é™¤äº† static è·¯å¾„å’Œç‰¹å®šçš„å‡ ä¸ªèµ„æºæ–‡ä»¶è·¯å¾„å…¶ä½™çš„æ–‡ä»¶éƒ½å‘ä¸‹èµ° handleRequest å‡½æ•°;
è¿™é‡Œé¢å°±æ˜¯å¤„ç†å„ç§æ–‡ä»¶èµ„æºè¯·æ±‚çš„æ–¹å¼ï¼Œè­¬å¦‚æœ‰å¯¹ tar æ–‡ä»¶æ ¼å¼èµ„æºçš„å¤„ç†å’Œ webview æ–‡ä»¶èµ„æºå¤„ç†è¿˜æœ‰é™æ€èµ„æºçš„å¤„ç†ç­‰ï¼Œå½“ç„¶é‡Œé¢è¿˜æœ‰ heartbeat å¿ƒè·³;

æ­¤æ—¶ Server æŠ½è±¡ç±»çš„ä¸»è¦ä»»åŠ¡å®Œæˆäº†ï¼Œå‰©ä¸‹çš„äº¤ç»™ MainServerï¼Œå…¶æ„é€ å‡½æ•°é‡Œå…ˆæ‰§è¡Œ initializeServices æ–¹æ³•ï¼›

é‡Œé¢å°±æ˜¯æ³¨å†Œäº†ä¸€äº› ipc é€šé“ï¼Œå¦‚ `logger` æ—¥å¿—ï¼Œæ’ä»¶ debugï¼Œ`telemetry` é¥æµ‹ï¼Œ`nodeProxy` node ä»£ç†ç­‰ç­‰ç­‰ç­‰
ä»¥åŠæ³¨å†Œä¸€äº›ä¾èµ–æ³¨å…¥é¡¹æœåŠ¡ï¼Œå¦‚ `ILogService` æœåŠ¡ï¼Œ`IFileService` æ–‡ä»¶æœåŠ¡ç­‰ç­‰

```typescript
private async initializeServices(args: ParsedArgs): Promise<void> {
    const environmentService = new EnvironmentService(args, process.execPath);
    const logService = new SpdLogService(RemoteExtensionLogFileName, environmentService.logsPath, getLogLevel(environmentService));
    const fileService = new FileService(logService);
    fileService.registerProvider(Schemas.file, new DiskFileSystemProvider(logService));

    this.allowedRequestPaths.push(
        path.join(environmentService.userDataPath, "clp"), // Language packs.
        environmentService.extensionsPath,
        environmentService.builtinExtensionsPath,
        ...environmentService.extraExtensionPaths,
        ...environmentService.extraBuiltinExtensionPaths,
    );

    this.ipc.registerChannel("logger", new LoggerChannel(logService));
    this.ipc.registerChannel(ExtensionHostDebugBroadcastChannel.ChannelName, new ExtensionHostDebugBroadcastChannel());

    this.services.set(ILogService, logService);
    this.services.set(IEnvironmentService, environmentService);
    this.services.set(IConfigurationService, new SyncDescriptor(ConfigurationService, [environmentService.machineSettingsResource]));
    this.services.set(IRequestService, new SyncDescriptor(RequestService));
    this.services.set(IFileService, fileService);
    this.services.set(IProductService, { _serviceBrand: undefined, ...product });
    this.services.set(IExtensionGalleryService, new SyncDescriptor(ExtensionGalleryService));
    this.services.set(IExtensionManagementService, new SyncDescriptor(ExtensionManagementService));

    if (!environmentService.args["disable-telemetry"]) {
        this.services.set(ITelemetryService, new SyncDescriptor(TelemetryService, [{
            appender: combinedAppender(
                new AppInsightsAppender("code-server", null, () => new TelemetryClient(), logService),
                new LogAppender(logService),
            ),
            commonProperties: resolveCommonProperties(
                product.commit, product.codeServerVersion, await getMachineId(),
                [], environmentService.installSourcePath, "code-server",
            ),
            piiPaths: this.allowedRequestPaths,
        } as ITelemetryServiceConfig]));
    } else {
        this.services.set(ITelemetryService, NullTelemetryService);
    }

    await new Promise((resolve) => {
        const instantiationService = new InstantiationService(this.services);
        this.services.set(ILocalizationsService, instantiationService.createInstance(LocalizationsService));
        this.services.set(INodeProxyService, instantiationService.createInstance(NodeProxyService));

        instantiationService.invokeFunction(() => {
            instantiationService.createInstance(LogsDataCleaner);
            const telemetryService = this.services.get(ITelemetryService) as ITelemetryService;
            this.ipc.registerChannel("extensions", new ExtensionManagementChannel(
                this.services.get(IExtensionManagementService) as IExtensionManagementService,
                (context) => getUriTransformer(context.remoteAuthority),
            ));
            this.ipc.registerChannel("remoteextensionsenvironment", new ExtensionEnvironmentChannel(
                environmentService, logService, telemetryService, this.options.connectionToken || "",
            ));
            this.ipc.registerChannel("request", new RequestChannel(this.services.get(IRequestService) as IRequestService));
            this.ipc.registerChannel("telemetry", new TelemetryChannel(telemetryService));
            this.ipc.registerChannel("nodeProxy", new NodeProxyChannel(this.services.get(INodeProxyService) as INodeProxyService));
            this.ipc.registerChannel("localizations", createChannelReceiver(this.services.get(ILocalizationsService) as ILocalizationsService));
            this.ipc.registerChannel("update", new UpdateChannel(instantiationService.createInstance(UpdateService)));
            this.ipc.registerChannel(REMOTE_FILE_SYSTEM_CHANNEL_NAME, new FileProviderChannel(environmentService, logService));
            resolve(new ErrorTelemetry(telemetryService));
        });
    });
}
```

éƒ½å®ä¾‹åŒ–å®Œäº†ä¹‹åå°±è¢«æ‰§è¡Œ `listen` æ–¹æ³•äº†

```typescript
public async listen(): Promise<string> {
    const environment = (this.services.get(IEnvironmentService) as EnvironmentService);
    const [address] = await Promise.all<string>([
        super.listen(), ...[
            environment.extensionsPath,
        ].map((p) => mkdirp(p).then(() => p)),
    ]);
    return address;
}
```

å…¶ä¸­ super.listen() é‡Œçš„ `listen` æ–¹æ³•ä¸º

```typescript
public listen(): Promise<string> {
    if (!this.listenPromise) {
        this.listenPromise = new Promise((resolve, reject) => {
            this.server.on("error", reject);
            this.server.on("upgrade", this.onUpgrade);
            const onListen = () => resolve(this.address());
            if (this.options.socket) {
                this.server.listen(this.options.socket, onListen);
            } else {
                this.server.listen(this.options.port, this.options.host, onListen);
            }
        });
    }
    return this.listenPromise;
}
```

åŸæ¥ websocket å°±æ˜¯åœ¨ onUpgrade è¿™é‡Œå¼€å§‹å»ºç«‹çš„ï¼Œå®Œäº†ä¹‹åå¼€å§‹ç›‘å¬ç«¯å£ï¼Œé‡Œé¢åªæœ‰ä¸€æ®µå¯¹ websocket çš„é¢„å¤„ç†

```typescript
await this.preHandleWebSocket(request, socket);
```

é‡Œé¢éƒ½æ˜¯å¯¹ ws çš„åŸºæ“ï¼Œå®Œäº†åè¿”å› handleWebSocketï¼›ğŸ‘‡

```typescript
const protocol = new Protocol(await this.createProxy(socket), {
    reconnectionToken: <string>parsedUrl.query.reconnectionToken,
    reconnection: parsedUrl.query.reconnection === "true",
    skipWebSocketFrames: parsedUrl.query.skipWebSocketFrames === "true",
});
try {
    await this.connect(await protocol.handshake(), protocol);
} catch (error) {
    protocol.sendMessage({ type: "error", reason: error.message });
    protocol.dispose();
    protocol.getSocket().dispose();
}
```

å…¶ä¸­ createProxy åˆ›å»ºçš„ä»£ç†åªæ˜¯å¤„ç† TLS å®‰å…¨ä¼ è¾“å±‚
Protocol ç»§æ‰¿äº† ipc.net (src/vs/base/parts/ipc/common/ipc.net.ts) é‡Œçš„ PersistentProtocol ç±»
è¯¥åè®®è§„å®šä¼ é€’çš„æ¶ˆæ¯å¿…é¡»ä¸º VSBuffer

```typescript
readonly onControlMessage: Event<VSBuffer>
```

> æ³¨ï¼š VSBuffer å¹¶ä¸æ˜¯ buffer äºŒè¿›åˆ¶ï¼Œè€Œä¸” vscode è‡ªå·±å®šä¹‰çš„ç±»

å…¶ä¸­å°è£…äº† toString æ–¹æ³•ï¼Œ ä½¿å…¶è¿”å›äºŒè¿›åˆ¶ buffer

```typescript
toString(): string {
    if (hasBuffer) {
        return this.buffer.toString();
    } else {
        if (!textDecoder) {
            textDecoder = new TextDecoder();
        }
        return textDecoder.decode(this.buffer);
    }
}
```

ç„¶åæ¥çœ‹çœ‹ protocol é‡Œçš„ handshake æ–¹æ³•

```typescript
/**
* Perform a handshake to get a connection request.
*/
public handshake(): Promise<ConnectionTypeRequest> {
    return new Promise((resolve, reject) => {
        const handler = this.onControlMessage((rawMessage) => {
            try {
                const message = JSON.parse(rawMessage.toString());
                switch (message.type) {
                    case "auth": return this.authenticate(message);
                    case "connectionType":
                        handler.dispose();
                        return resolve(message);
                    default: throw new Error("Unrecognized message type");
                }
            } catch (error) {
                handler.dispose();
                reject(error);
            }
        });
    });
}
```

å»ºç«‹åè®®çš„æ¡æ‰‹ä¹‹åç›´æ¥è¿”å›äº† message æ¶ˆæ¯ï¼Œç„¶åä¸åè®®æœ¬èº«ä¸€èµ·ä¸¢è¿›äº† connect æ–¹æ³•é‡Œï¼›

å…¶é‡Œé¢å°±æ˜¯å¯¹æ‰€æœ‰æ‰€éœ€çš„è¿æ¥ç±»å‹åˆ†åˆ«åšå¤„ç†ï¼Œç±»å‹åˆ†ä¸ºä¸‰ç§

```typescript
export const enum ConnectionType {
	Management = 1,
	ExtensionHost = 2,
	Tunnel = 3,
}
```

ä¸»ç®¡ç†ã€æ’ä»¶è¿›ç¨‹å’Œéš§é“ï¼Œå‰©ä¸‹çš„éƒ½æ˜¯å¯¹ä¸åŒæ¶ˆæ¯ç±»å‹çš„è¿æ¥å¤„ç†äº†

æ­¤æ—¶ server ç«¯çš„ä¸»è¦ä»»åŠ¡ä¹Ÿå®Œæˆäº†ï¼Œæ¥ä¸‹æ¥è®©æˆ‘ä»¬ä»ä¸»é¡µé¢ workbench.html è¿›å»çœ‹çœ‹













