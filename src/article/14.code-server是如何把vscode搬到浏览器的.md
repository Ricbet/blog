[code-server](https://github.com/cdr/code-server/tree/2.1692-vsc1.39.2) æ˜¯ä¸€ä¸ªå¼€æºçš„åœ¨çº¿ vscode è¿œç«¯è¿è¡ŒæœåŠ¡ï¼Œæœ¬æ–‡ä»æºç è§’åº¦æ¥è§£è¯»ä»–æ˜¯å¦‚ä½•æŠŠ vscode æ¬åˆ°æµè§ˆå™¨è¿è¡Œçš„

> vscode ç‰ˆæœ¬ 1.39.2 </br>
> node ç‰ˆæœ¬ 10.16.0

### å…ˆé¢„çƒ­ä¸€ä¸‹ vscode æ¶æ„

![1.png](../assets/img/14/1.png)

ä½œä¸ºæœ¬åœ°çš„ `Electron` åº”ç”¨ï¼Œä»–é‡‡ç”¨çš„æ˜¯å¤šè¿›ç¨‹æ¶æ„;

ä¸»è¿›ç¨‹å’Œå¾ˆå¤šå­è¿›ç¨‹ä¹‹é—´è¿›è¡Œ `IPC` é€šä¿¡æˆ– `RPC` è¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼Œå…¶ä¸­æ’ä»¶ç³»ç»Ÿä¹Ÿä½œä¸ºäº†ä¸€ä¸ªè¿›ç¨‹ï¼Œæ‰€æœ‰çš„æ’ä»¶éƒ½ä¼šåœ¨è¿™ä¸ªè¿›ç¨‹ä¸‹è¿è¡Œï¼ŒåŒ…æ‹¬è¯­è¨€æœåŠ¡åè®®ç­‰;

`debug` åè®®ä¸å…¶ä»–è¿›ç¨‹ä¸åŒï¼Œæ¯æ¬¡æ‰§è¡Œ `debug` éƒ½ä¼šæ–°å¼€ä¸€ä¸ªå­è¿›ç¨‹;

å…¶ä¸­è¾ƒä¸ºå¸¸è§çš„æ–‡ä»¶è¯»å†™éƒ½æ˜¯åœ¨ `main` ä¸»è¿›ç¨‹ä¸­å®Œæˆ;

### coder å¼€å‘æµç¨‹

åœ¨ coder-server çš„ README é‡Œæœ‰å¼€å‘æµç¨‹æ­¥éª¤ï¼Œå¤§æŠµä¸Šåˆ†ä¸º

```shell
git clone https://github.com/microsoft/vscode
cd vscode
git checkout ${vscodeVersion} # See travis.yml for the version to use.
yarn
git clone https://github.com/cdr/code-server src/vs/server
cd src/vs/server
yarn
yarn patch:apply
yarn watch
# Wait for the initial compilation to complete (it will say "Finished compilation").
# Run the next command in another shell.
yarn start
# Visit http://localhost:8080
```

1. å…ˆ `clone` vscode é¡¹ç›®å¹¶åˆ‡æ¢åˆ°æŸå›ºå®šç‰ˆæœ¬
2. æŠŠè‡ªå·± `clone` åˆ° `src/vs/server` ç›®å½•ä¸‹
3. æŠŠé­”æ”¹çš„éƒ¨åˆ†é€šè¿‡è¡¥ä¸ `patch` æ‰“è¿› `vscodeï¼Œæ‰§è¡Œ` `watch` å°† `vscode` é¡¹ç›®é‡Œçš„ ts ä»£ç ç¼–è¯‘æˆå¯æ‰§è¡Œçš„ js æ–‡ä»¶å¹¶è¾“å‡ºåˆ° `out` ç›®å½•
4. start å…¶å®å°±æ˜¯ç”¨ node è·‘ out/vs/server/main.js æ–‡ä»¶

æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è®¤ä¸ºä»–å®Œå…¨æ˜¯å……å½“äº† `vscode` çš„ `server` ç«¯ï¼Œä¸ºå…¶ web ç‰ˆæä¾›æ”¯æŒèƒ½åŠ›ï¼Œé‡ç‚¹å°±æ˜¯åœ¨ `patch` è¡¥ä¸éƒ¨åˆ†

### ç›®å½•

```tree
scripts
â”œâ”€â”€ build.ts                        // ä¸»è¦çš„ build è„šæœ¬æ–‡ä»¶ï¼Œåˆ†ä¸º buildã€binaryã€package å’Œ ensure-in-vscode å››ç§ task
â”œâ”€â”€ ci.bash                         // ç”¨äºè·‘ CI æ„å»ºæµç¨‹ï¼Œåˆ†ä¸º docker-build å’Œ local-build
â”œâ”€â”€ ci.dockerfile
â”œâ”€â”€ optimize.js
â”œâ”€â”€ package.json
â”œâ”€â”€ product.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ vscode.patch                    // é’ˆå¯¹ vscode 1.39.2 ç‰ˆæœ¬æ‰“çš„ git patch æ–‡ä»¶
src
â”œâ”€â”€ browser                         // ä¸»è¦æ˜¯ client ç«¯çš„å®ç°
â”‚   â”œâ”€â”€ api.ts                      // vscode å®¢æˆ·ç«¯çš„ api å®ç°
â”‚   â”œâ”€â”€ client.ts                   // å®¢æˆ·ç«¯åˆå§‹åŒ–æ‰§è¡Œ
â”‚   â”œâ”€â”€ extHostNodeProxy.ts         // æ’ä»¶ä»£ç†ï¼Œé€šè¿‡è¡¥ä¸æ‰“åœ¨äº† src/vs/workbench/services/extensions/worker/extHost.services.ts ç›®å½•ä½œä¸ºå•ä¾‹æœåŠ¡ï¼Œè¿›è¡Œ rpc è¿œç¨‹è¿‡ç¨‹è°ƒç”¨
â”‚   â”œâ”€â”€ login.html                  // ç™»é™†æˆæƒ
â”‚   â”œâ”€â”€ mainThreadNodeProxy.ts      // ä¸»çº¿ç¨‹ä»£ç†
â”‚   â”œâ”€â”€ upload.ts                   // ä¸Šè½½æœåŠ¡ï¼Œæ‹–åŠ¨æ–‡ä»¶åœ¨æ–‡ä»¶æ ‘å°±æ‰§è¡Œè¯¥æœåŠ¡
â”‚   â”œâ”€â”€ workbench-build.html
â”‚   â”œâ”€â”€ workbench.html              // å…¥å£ html æ–‡ä»¶
â”‚   â””â”€â”€ worker.ts                   // å¤å†™ src/vs/workbench/api/worker/extHostExtensionService.ts ç›®å½•ä¸‹ _loadCommonJSModule æ–¹æ³•ï¼Œå…¶ä¸­å…³é”®ç”¨åˆ° coder è‡ªå·±å°è£…çš„ node-browser å’Œ requirefsï¼Œä¸ºæµè§ˆå™¨æä¾›è¯¸å¦‚ fsã€netã€require çš„èƒ½åŠ›
â”œâ”€â”€ common                          // server ç«¯å’Œ client ç«¯éƒ½å¯ä½¿ç”¨çš„æœåŠ¡
â”‚   â”œâ”€â”€ nodeProxy.ts                // ä»£ç†éš§é“æœåŠ¡
â”‚   â”œâ”€â”€ telemetry.ts                // é¥æµ‹éš§é“æœåŠ¡
â”‚   â””â”€â”€ util.ts
â”œâ”€â”€ media
â”‚   â”œâ”€â”€ code-server.png
â”‚   â”œâ”€â”€ favicon.ico
â”‚   â”œâ”€â”€ login.css
â”‚   â””â”€â”€ manifest.json
â””â”€â”€ node                            // æœåŠ¡ç«¯ server å®ç°
    â”œâ”€â”€ channel.ts                  // ä¸»è¦
    â”œâ”€â”€ cli.ts
    â”œâ”€â”€ connection.ts               // ä¸»è¦ç”¨äº ipc é€šé“è¿æ¥
    â”œâ”€â”€ insights.ts
    â”œâ”€â”€ ipc.ts
    â”œâ”€â”€ marketplace.ts
    â”œâ”€â”€ nls.ts
    â”œâ”€â”€ protocol.ts                 // ä¸»è¦æ˜¯ websocket çš„åè®®
    â”œâ”€â”€ server.ts
    â”œâ”€â”€ update.ts
    â”œâ”€â”€ uriTransformer.js
    â””â”€â”€ util.ts
typings
â”œâ”€â”€ api.d.ts    
â”œâ”€â”€ httpolyglot.d.ts
â””â”€â”€ package.json
```

### å¯åŠ¨é¡ºåº

åœ¨ `server` ç›®å½•ä¸‹æ‰§è¡Œ `start` å‘½ä»¤å…¶å®å°±æ˜¯ç”¨ `node` è·‘ `out/vs/server/main.js` æ–‡ä»¶

`main` æ–‡ä»¶æ ¸å¿ƒå°±ä¸€è¡Œ

> require("../../bootstrap-amd").load("vs/server/src/node/cli");

é€šè¿‡ `amd` æ¨¡å—åŠ è½½ `cli` æ–‡ä»¶ï¼Œè€Œè¿™ä¸ª `cli` æ–‡ä»¶å°±æ˜¯ä½äº server/node/cli;

è¯¥æ–‡ä»¶æ‰§è¡Œ <span id="main">`main`</span> å‡½æ•°
```typescript
const main = async(): Promise<boolean | void | void[]> => {
	const args = getArgs();
	if (process.env.LAUNCH_VSCODE) {
		await ipcMain.handshake();
		return startVscode(args);
	}
	return startCli(args) || new WrapperProcess(args).start();
};
```

è¿™ä¸€æ­¥å¼€å§‹å…¶å® `LAUNCH_VSCODE` ç¯å¢ƒå˜é‡åˆå§‹ä¸ºç©ºï¼Œ`startCli` å‡½æ•°å…¶å®é‡Œé¢ä¹Ÿæ˜¯æ ¹æ®ç¯å¢ƒå˜é‡å‚æ•°åšä¸€äº›åˆ¤æ–­å¤„ç†ï¼Œä½†åˆå§‹éƒ½ä¸ºç©ºï¼Œå…³é”®æ˜¯è¿™ä¸ª `WrapperProcess`;

å®ä¾‹åŒ– `WrapperProcess` çš„æ—¶å€™ä¾¿å¼€å§‹è¿›è¡Œ `ipc` çš„æ¡æ‰‹ï¼Œç”¨äºè¿›ç¨‹ä¹‹é—´çš„é€šä¿¡ï¼Œå®Œäº†ä¹‹åæ‰§è¡Œ `start` å‡½æ•°

```typescript
if (!this.started) {
    const child = this.spawn();
    this.started = ipcMain.handshake(child).then(() => {
        child.once("exit", (code) => exit(code!));
    });
    this.process = child;
}
return this.started;
```

é€šè¿‡ `spawn` åˆ›å»ºå­è¿›ç¨‹, è€Œå…¶ä¸­ `spawn` åšäº†ä»¥ä¸‹äº‹æƒ…

```typescript
//...
const isBinary = (global as any).NBIN_LOADED;
return cp.spawn(process.argv[0], process.argv.slice(isBinary ? 2 : 1), {
    env: {
        ...process.env,
        LAUNCH_VSCODE: "true",
        NBIN_BYPASS: undefined,
        VSCODE_PARENT_PID: process.pid.toString(),
        NODE_OPTIONS: nodeOptions,
    },
    stdio: ["inherit", "inherit", "inherit", "ipc"],
});
```

> `NBIN_LOADED` ç¯å¢ƒå…¶å®æ˜¯ `coder` è‡ªå®šä¹‰çš„ï¼Œ[nbin](https://github.com/cdr/nbin) ä¸»è¦æ˜¯é€šè¿‡ç»™ `node` çš„ `fs` æ¨¡å—æ‰“è¡¥ä¸ä¸€é¡¿é­”æ”¹è¾¾åˆ°å¢å¼ºäºŒè¿›åˆ¶ç¼–è¯‘çš„è¿‡ç¨‹ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºå•¥ä¼šå¯¹ `node` ç‰ˆæœ¬å…·æœ‰å¼ºçº¦æŸæ€§çš„åŸå› ï¼ˆéªšã€‚ã€‚ã€‚

ä½¿ç”¨å½“å‰çš„æ‰€æœ‰å‚æ•°é‡æ–°åˆ›å»ºäº†ä¸€ä¸ªå­è¿›ç¨‹å¹¶è¿”å›ï¼Œå…¶ä¸­ `stdio` æŒ‡å®šäº† `ipc` `é€šé“ï¼ŒLAUNCH_VSCODE` ç¯å¢ƒå˜é‡ä¹Ÿè®¾ç½®ä¸ºäº† trueï¼Œæ­¤æ—¶ `main` å‡½æ•°è¢« `é‡æ–°æ‰§è¡Œ` äº†;

å›åˆ° <a href="#main">`main`</a> è¿™é‡Œ, æ­¤æ—¶ç›´æ¥ç­‰å¾… `ipc` æ¡æ‰‹ä¹‹åè¿è¡Œ `startVscode`;

```typescript
//...

const server = new MainServer({
    ...options,
    port: typeof args.port !== "undefined" ? parseInt(args.port, 10) : 8080,
    socket: args.socket,
}, args);

const [serverAddress, /* ignore */] = await Promise.all([
    server.listen(),
    unpackExecutables(),
]);

//...
```

å¯ä»¥æ€»ç»“ä¸ºï¼Œ`cli` å…¶å®å°±æ˜¯å»ºç«‹ `ipc` é€šé“å¹¶é¢„å¤„ç†ä¸€å¤§å †å‚æ•°ä»è€Œå¯åŠ¨ `server` çš„è¿‡ç¨‹;

### Server ç«¯

æ¥åˆ° `server` ç«¯çš„ `MainServer` å‡½æ•°ï¼Œå®ƒç»§æ‰¿äº†æŠ½è±¡ç±» `Server`ï¼Œå¹¶åœ¨æ„é€ å‡½æ•°é‡Œå¯åŠ¨ `http` æœåŠ¡

```typescript
public constructor(options: ServerOptions) {
    this.options = {
        host: options.auth === "password" && options.cert ? "0.0.0.0" : "localhost",
        ...options,
        basePath: options.basePath ? options.basePath.replace(/\/+$/, "") : "",
        password: options.password ? hash(options.password) : undefined,
    };
    this.protocol = this.options.cert ? "https" : "http";
    if (this.protocol === "https") {
        const httpolyglot = localRequire<typeof import("httpolyglot")>("httpolyglot/lib/index");
        this.server = httpolyglot.createServer({
            cert: this.options.cert && fs.readFileSync(this.options.cert),
            key: this.options.certKey && fs.readFileSync(this.options.certKey),
        }, this.onRequest);
    } else {
        this.server = http.createServer(this.onRequest);
    }
}
```

å…¶ä¸­ `cert` å‚æ•°åšäº†è‡ªç­¾åè¯ä¹¦å¤„ç†ï¼Œæˆ‘çŒœæµ‹æ˜¯ä¸ºäº†å®‰å…¨è€ƒè™‘å§ã€‚ã€‚

`onRequest` æ–¹æ³•é‡Œå¯¹è¯·æ±‚å¤´åšäº†é¢„å¤„ç†

```typescript
//...
const payload = await this.preHandleRequest(request, parsedUrl);
//...
```

`preHandleRequest` æ–¹æ³•é‡Œå¯¹è¯·æ±‚çš„è·¯å¾„åšäº†ä¸€é€šæ‹¦æˆªå¤„ç†ï¼Œå…¶ä¸­æœ‰ä¸€æ®µ

```typescript
// Allow for a versioned static endpoint. This lets us cache every static
// resource underneath the path based on the version without any work and
// without adding query parameters which have their own issues.
// REVIEW: Discuss whether this is the best option; this is sort of a quick
// hack almost to get caching in the meantime but it does work pretty well.
if (/^\/static-/.test(base)) {
    base = "/static";
}
```

é€šè¿‡æ­£åˆ™åŒ¹é…æ‰€æœ‰è·¯å¾„é‡Œå¼€å¤´å«æœ‰ `static-` çš„æ–‡ä»¶å°† `base` è·¯å¾„é‡ç½®ä¸º `/static` ï¼Œä¸ºäº†åé¢åšç¼“å­˜å¤„ç†

```typescript
//...
case "/static":
    const response = await this.getResource(this.rootPath, requestPath);
    response.cache = true;
    return response;
//...
```

å…¶ä¸­ `getResource` å°±æ˜¯ç›´æ¥è¯»æ–‡ä»¶å†…å®¹å¹¶è¿”å›

```typescript
protected async getResource(...parts: string[]): Promise<Response> {
    const filePath = this.ensureAuthorizedFilePath(...parts);
    return { content: await util.promisify(fs.readFile)(filePath), filePath };
}
```

é™¤äº† `static` è·¯å¾„å’Œç‰¹å®šçš„å‡ ä¸ªèµ„æºæ–‡ä»¶è·¯å¾„å…¶ä½™çš„æ–‡ä»¶éƒ½å‘ä¸‹èµ° `handleRequest` å‡½æ•°;

è¿™é‡Œé¢å°±æ˜¯å¤„ç†å„ç§æ–‡ä»¶èµ„æºè¯·æ±‚çš„æ–¹å¼ï¼Œè­¬å¦‚æœ‰å¯¹ `tar` æ–‡ä»¶æ ¼å¼èµ„æºçš„å¤„ç†å’Œ `webview` æ–‡ä»¶èµ„æºå¤„ç†è¿˜æœ‰é™æ€èµ„æºçš„å¤„ç†ç­‰ï¼Œå½“ç„¶é‡Œé¢è¿˜æœ‰ `heartbeat` å¿ƒè·³;

å¯¹äºæ ¹è·¯å¾„ `/` è¿”å›çš„æ˜¯ `getRoot` å‡½æ•°

```typescript
case "/": return this.getRoot(request, parsedUrl);
```

`getRoot` å‡½æ•°é‡Œå¯¹ `src/vs/server/src/browser/workbench.html` åšäº†ä¸€äº›æ–‡æœ¬æ›¿æ¢å¤„ç†ï¼›ğŸ‘‡

```typescript
private async getRoot(request: http.IncomingMessage, parsedUrl: url.UrlWithParsedQuery): Promise<Response> {
    const filePath = path.join(this.serverRoot, "browser/workbench.html");
    let [content, startPath] = await Promise.all([
        util.promisify(fs.readFile)(filePath, "utf8"),
        this.getFirstValidPath([
            { path: parsedUrl.query.workspace, workspace: true },
            { path: parsedUrl.query.folder, workspace: false },
            (await this.readSettings()).lastVisited,
            { path: this.options.openUri }
        ]),
        this.servicesPromise,
    ]);

    if (startPath) {
        this.writeSettings({
            lastVisited: {
                path: startPath.uri.fsPath,
                workspace: startPath.workspace
            },
        });
    }

    const logger = this.services.get(ILogService) as ILogService;
    logger.info("request.url", `"${request.url}"`);

    const remoteAuthority = request.headers.host as string;
    const transformer = getUriTransformer(remoteAuthority);

    const environment = this.services.get(IEnvironmentService) as IEnvironmentService;
    const options: Options = {
        WORKBENCH_WEB_CONFIGURATION: {
            workspaceUri: startPath && startPath.workspace ? transformer.transformOutgoing(startPath.uri) : undefined,
            folderUri: startPath && !startPath.workspace ? transformer.transformOutgoing(startPath.uri) : undefined,
            remoteAuthority,
            logLevel: getLogLevel(environment),
        },
        REMOTE_USER_DATA_URI: transformer.transformOutgoing(URI.file(environment.userDataPath)),
        PRODUCT_CONFIGURATION: {
            extensionsGallery: product.extensionsGallery,
        },
        NLS_CONFIGURATION: await getNlsConfiguration(environment.args.locale || await getLocaleFromConfig(environment.userDataPath), environment.userDataPath),
    };

    content = content.replace(/{{COMMIT}}/g, product.commit || "");
    for (const key in options) {
        content = content.replace(`"{{${key}}}"`, `'${JSON.stringify(options[key as keyof Options])}'`);
    }

    return { content, filePath };
}
```

é¦–å…ˆå®ƒç›´æ¥è¯»å–äº† `workbench.html` çš„å†…å®¹ï¼Œç„¶åæ ¹æ® `options` çš„ `key` æ›¿æ¢æ‰ `html` æ–‡ä»¶é‡Œçš„å ä½ç¬¦ï¼Œå¦‚ `uri` çš„è½¬æ¢ã€`nls` å¤šè¯­è¨€çš„é…ç½®ã€`workbench` é…ç½®ç­‰ï¼Œç„¶åè¿”å›æ–‡ä»¶å†…å®¹å’Œè·¯å¾„ï¼›

```html
<!-- Workbench Configuration -->
<meta id="vscode-workbench-web-configuration" data-settings="{{WORKBENCH_WEB_CONFIGURATION}}">

<!-- Workarounds/Hacks (remote user data uri) -->
<meta id="vscode-remote-user-data-uri" data-settings="{{REMOTE_USER_DATA_URI}}">
<!-- NOTE@coder: Added the commit for use in caching, the product for the
extensions gallery URL, and nls for language support. -->
<meta id="vscode-remote-commit" data-settings="{{COMMIT}}">
<meta id="vscode-remote-product-configuration" data-settings="{{PRODUCT_CONFIGURATION}}">
<meta id="vscode-remote-nls-configuration" data-settings="{{NLS_CONFIGURATION}}">
```

å…¶ä¸­ `getFirstValidPath` æ–¹æ³•æ˜¯ç”¨äºæŒ‡å®šåˆå§‹çš„æ—¶å€™è¦æ‰“å¼€çš„å·¥ä½œåŒºå’Œæ–‡ä»¶ï¼›

æ­¤æ—¶ `Server` æŠ½è±¡ç±»çš„ä¸»è¦ä»»åŠ¡å®Œæˆäº†ï¼Œå‰©ä¸‹çš„äº¤ç»™ `MainServer`ï¼Œå…¶æ„é€ å‡½æ•°é‡Œå…ˆæ‰§è¡Œ `initializeServices` æ–¹æ³•ï¼›

é‡Œé¢å°±æ˜¯æ³¨å†Œäº†ä¸€äº› ipc é€šé“ï¼Œå¦‚ `logger` æ—¥å¿—ï¼Œæ’ä»¶ debugï¼Œ`telemetry` é¥æµ‹ï¼Œ`nodeProxy` node ä»£ç†ç­‰ç­‰;

ä»¥åŠæ³¨å†Œä¸€äº›ä¾èµ–æ³¨å…¥é¡¹æœåŠ¡ï¼Œå¦‚ `ILogService` æœåŠ¡ï¼Œ`IFileService` æ–‡ä»¶æœåŠ¡ç­‰ç­‰;

```typescript
private async initializeServices(args: ParsedArgs): Promise<void> {
    const environmentService = new EnvironmentService(args, process.execPath);
    const logService = new SpdLogService(RemoteExtensionLogFileName, environmentService.logsPath, getLogLevel(environmentService));
    const fileService = new FileService(logService);
    fileService.registerProvider(Schemas.file, new DiskFileSystemProvider(logService));

    this.allowedRequestPaths.push(
        path.join(environmentService.userDataPath, "clp"), // Language packs.
        environmentService.extensionsPath,
        environmentService.builtinExtensionsPath,
        ...environmentService.extraExtensionPaths,
        ...environmentService.extraBuiltinExtensionPaths,
    );

    this.ipc.registerChannel("logger", new LoggerChannel(logService));
    this.ipc.registerChannel(ExtensionHostDebugBroadcastChannel.ChannelName, new ExtensionHostDebugBroadcastChannel());

    this.services.set(ILogService, logService);
    this.services.set(IEnvironmentService, environmentService);
    this.services.set(IConfigurationService, new SyncDescriptor(ConfigurationService, [environmentService.machineSettingsResource]));
    this.services.set(IRequestService, new SyncDescriptor(RequestService));
    this.services.set(IFileService, fileService);
    this.services.set(IProductService, { _serviceBrand: undefined, ...product });
    this.services.set(IExtensionGalleryService, new SyncDescriptor(ExtensionGalleryService));
    this.services.set(IExtensionManagementService, new SyncDescriptor(ExtensionManagementService));

    if (!environmentService.args["disable-telemetry"]) {
        this.services.set(ITelemetryService, new SyncDescriptor(TelemetryService, [{
            appender: combinedAppender(
                new AppInsightsAppender("code-server", null, () => new TelemetryClient(), logService),
                new LogAppender(logService),
            ),
            commonProperties: resolveCommonProperties(
                product.commit, product.codeServerVersion, await getMachineId(),
                [], environmentService.installSourcePath, "code-server",
            ),
            piiPaths: this.allowedRequestPaths,
        } as ITelemetryServiceConfig]));
    } else {
        this.services.set(ITelemetryService, NullTelemetryService);
    }

    await new Promise((resolve) => {
        const instantiationService = new InstantiationService(this.services);
        this.services.set(ILocalizationsService, instantiationService.createInstance(LocalizationsService));
        this.services.set(INodeProxyService, instantiationService.createInstance(NodeProxyService));

        instantiationService.invokeFunction(() => {
            instantiationService.createInstance(LogsDataCleaner);
            const telemetryService = this.services.get(ITelemetryService) as ITelemetryService;
            this.ipc.registerChannel("extensions", new ExtensionManagementChannel(
                this.services.get(IExtensionManagementService) as IExtensionManagementService,
                (context) => getUriTransformer(context.remoteAuthority),
            ));
            this.ipc.registerChannel("remoteextensionsenvironment", new ExtensionEnvironmentChannel(
                environmentService, logService, telemetryService, this.options.connectionToken || "",
            ));
            this.ipc.registerChannel("request", new RequestChannel(this.services.get(IRequestService) as IRequestService));
            this.ipc.registerChannel("telemetry", new TelemetryChannel(telemetryService));
            this.ipc.registerChannel("nodeProxy", new NodeProxyChannel(this.services.get(INodeProxyService) as INodeProxyService));
            this.ipc.registerChannel("localizations", createChannelReceiver(this.services.get(ILocalizationsService) as ILocalizationsService));
            this.ipc.registerChannel("update", new UpdateChannel(instantiationService.createInstance(UpdateService)));
            this.ipc.registerChannel(REMOTE_FILE_SYSTEM_CHANNEL_NAME, new FileProviderChannel(environmentService, logService));
            resolve(new ErrorTelemetry(telemetryService));
        });
    });
}
```

éƒ½å®ä¾‹åŒ–å®Œäº†ä¹‹åå°±è¢«æ‰§è¡Œ `listen` æ–¹æ³•äº†

```typescript
public async listen(): Promise<string> {
    const environment = (this.services.get(IEnvironmentService) as EnvironmentService);
    const [address] = await Promise.all<string>([
        super.listen(), ...[
            environment.extensionsPath,
        ].map((p) => mkdirp(p).then(() => p)),
    ]);
    return address;
}
```

å…¶ä¸­ super.listen() é‡Œçš„ `listen` æ–¹æ³•ä¸º

```typescript
public listen(): Promise<string> {
    if (!this.listenPromise) {
        this.listenPromise = new Promise((resolve, reject) => {
            this.server.on("error", reject);
            this.server.on("upgrade", this.onUpgrade);
            const onListen = () => resolve(this.address());
            if (this.options.socket) {
                this.server.listen(this.options.socket, onListen);
            } else {
                this.server.listen(this.options.port, this.options.host, onListen);
            }
        });
    }
    return this.listenPromise;
}
```

åŸæ¥ `websocket` å°±æ˜¯åœ¨ `onUpgrade` è¿™é‡Œå¼€å§‹å»ºç«‹çš„ï¼Œå®Œäº†ä¹‹åå¼€å§‹ç›‘å¬ç«¯å£ï¼Œé‡Œé¢åªæœ‰ä¸€æ®µå¯¹ `websocket` çš„é¢„å¤„ç†

```typescript
await this.preHandleWebSocket(request, socket);
```

é‡Œé¢éƒ½æ˜¯å¯¹ `ws` çš„åŸºæ“ï¼Œå®Œäº†åè¿”å› `handleWebSocket`ï¼›ğŸ‘‡

```typescript
const protocol = new Protocol(await this.createProxy(socket), {
    reconnectionToken: <string>parsedUrl.query.reconnectionToken,
    reconnection: parsedUrl.query.reconnection === "true",
    skipWebSocketFrames: parsedUrl.query.skipWebSocketFrames === "true",
});
try {
    await this.connect(await protocol.handshake(), protocol);
} catch (error) {
    protocol.sendMessage({ type: "error", reason: error.message });
    protocol.dispose();
    protocol.getSocket().dispose();
}
```

å…¶ä¸­ `createProxy` åˆ›å»ºçš„ä»£ç†åªæ˜¯å¤„ç† `TLS` æ¨¡å—ï¼Œå¦‚æœ `socket` å±äº `TLSSocket` ç±»å‹ï¼Œå®ƒæ˜¯éœ€è¦è¯ä¹¦å’Œå¯†é’¥çš„ï¼Œæ‰€ä»¥å°†å…¶è¿”å›çš„éƒ½æ˜¯é `TLSSocket`;

`Protocol` ç»§æ‰¿äº† `ipc.net` (åœ¨ src/vs/base/parts/ipc/common/ipc.net.ts ç›®å½•) é‡Œçš„ `PersistentProtocol` ç±»ï¼Œè¯¥åè®®è§„å®šä¼ é€’çš„æ¶ˆæ¯å¿…é¡»ä¸º `VSBuffer` ï¼ˆåœ¨ src/vs/base/common/buffer.ts ç›®å½•ï¼‰

```typescript
readonly onControlMessage: Event<VSBuffer>
```

ç„¶åæ¥çœ‹çœ‹ `protocol` é‡Œçš„ `handshake` æ–¹æ³•

```typescript
/**
* Perform a handshake to get a connection request.
*/
public handshake(): Promise<ConnectionTypeRequest> {
    return new Promise((resolve, reject) => {
        const handler = this.onControlMessage((rawMessage) => {
            try {
                const message = JSON.parse(rawMessage.toString());
                switch (message.type) {
                    case "auth": return this.authenticate(message);
                    case "connectionType":
                        handler.dispose();
                        return resolve(message);
                    default: throw new Error("Unrecognized message type");
                }
            } catch (error) {
                handler.dispose();
                reject(error);
            }
        });
    });
}
```

å»ºç«‹åè®®çš„æ¡æ‰‹ä¹‹åç›´æ¥è¿”å›çš„æ˜¯ `message` æ¶ˆæ¯ï¼Œç„¶åä¸åè®®æœ¬èº«ä¸€èµ·ä¸¢è¿›äº† `connect` æ–¹æ³•é‡Œï¼›

å…¶é‡Œé¢å°±æ˜¯å¯¹æ‰€æœ‰æ‰€éœ€çš„è¿æ¥ç±»å‹åˆ†åˆ«åšå¤„ç†ï¼Œç±»å‹åˆ†ä¸ºä¸‰ç§

```typescript
export const enum ConnectionType {
	Management = 1,
	ExtensionHost = 2,
	Tunnel = 3,
}
```

ç„¶ååˆ†åˆ«å¯¹è¿™ä¸‰ç§è¿æ¥ç±»å‹éƒ½åšäº†å¤„ç†ï¼›

```typescript
switch (message.desiredConnectionType) {
    case ConnectionType.ExtensionHost:
    case ConnectionType.Management:
        if (!this.connections.has(message.desiredConnectionType)) {
            this.connections.set(message.desiredConnectionType, new Map());
        }
        const connections = this.connections.get(message.desiredConnectionType)!;

        const ok = async () => {
            return message.desiredConnectionType === ConnectionType.ExtensionHost
                ? { debugPort: await this.getDebugPort() }
                : { type: "ok" };
        };

        const token = protocol.options.reconnectionToken;
        if (protocol.options.reconnection && connections.has(token)) {
            protocol.sendMessage(await ok());
            const buffer = protocol.readEntireBuffer();
            protocol.dispose();
            return connections.get(token)!.reconnect(protocol.getSocket(), buffer);
        } else if (protocol.options.reconnection || connections.has(token)) {
            throw new Error(protocol.options.reconnection
                ? "Unrecognized reconnection token"
                : "Duplicate reconnection token"
            );
        }

        protocol.sendMessage(await ok());

        let connection: Connection;
        if (message.desiredConnectionType === ConnectionType.Management) {
            connection = new ManagementConnection(protocol, token);
            this._onDidClientConnect.fire({
                protocol, onDidClientDisconnect: connection.onClose,
            });
            // TODO: Need a way to match clients with a connection. For now
            // dispose everything which only works because no extensions currently
            // utilize long-running proxies.
            (this.services.get(INodeProxyService) as NodeProxyService)._onUp.fire();
            connection.onClose(() => (this.services.get(INodeProxyService) as NodeProxyService)._onDown.fire());
        } else {
            const buffer = protocol.readEntireBuffer();
            connection = new ExtensionHostConnection(
                message.args ? message.args.language : "en",
                protocol, buffer, token,
                this.services.get(ILogService) as ILogService,
                this.services.get(IEnvironmentService) as IEnvironmentService,
            );
        }
        connections.set(token, connection);
        connection.onClose(() => connections.delete(token));
        this.disposeOldOfflineConnections(connections);
        break;
    case ConnectionType.Tunnel: return protocol.tunnel();
    default: throw new Error("Unrecognized connection type");
}
```

æ­¤æ—¶ `server` ç«¯çš„ä¸»è¦ä»»åŠ¡ä¹Ÿå®Œæˆäº†ï¼Œå¤§æŠµä¸Šåšäº†ä»¥ä¸‹äº‹æƒ…

- å¯åŠ¨ `http` æœåŠ¡
- å¤„ç†èµ„æºè¯·æ±‚è·¯å¾„
- æ³¨å†Œ `ipc` é€šé“å’Œä¾èµ–æ³¨å…¥
- å»ºç«‹ `websocket` é€šä¿¡

å½“ç„¶è¿˜æœ‰ `login` ç™»é™†å’Œå¿ƒè·³ç­‰ç»†èŠ‚æ“ä½œï¼›

æ¥ä¸‹æ¥æˆ‘ä»¬è¿›å…¥åˆ°å®ƒå¯åŠ¨çš„é»˜è®¤ç«¯å£ `8080` å»çœ‹çœ‹

### Workbench

å¯åŠ¨çš„æ—¶å€™éœ€è¦æŒ‡å®š `auth` å‚æ•°ä¸º `none`, è¿™æ ·å°±ä¸ä¼šè·³åˆ° `login` é¡µé¢ï¼›

é¦–å…ˆåŠ è½½çš„æ ¹è·¯å¾„è¿”å›ä¸Šæ–‡æåˆ°çš„ `workbench.html` æ–‡ä»¶å†…å®¹ï¼›

![3.png](../assets/img/14/3.png)

å¯ä»¥çœ‹åˆ°åŸæ¥çš„å ä½ç¬¦éƒ½è¢«æ›¿æ¢æˆäº†é…ç½®é¡¹ï¼Œè€Œä¸”é‡‡ç”¨çš„æ˜¯ `require.js` AMD æ¨¡å—åŒ–æ¨¡å¼ï¼›

é…ç½®äº† `baseUrl` å’Œ `paths` å‚æ•°ï¼ŒæŒ‡å®šå„ä¸ªæ¨¡å—çš„è·¯å¾„ï¼Œç”±äºéƒ½å¯¹è¿™äº›æ¨¡å—åŠ ä¸Šäº† `staticBase` è·¯å¾„ï¼Œè€Œåœ¨ä¸Šæ–‡æåˆ°è¿‡çš„ `/static-` ä½¿å¾—å¯¹è¿™äº›æ–‡ä»¶åšäº†ç¼“å­˜å¤„ç†ï¼›

æ¥ä¸‹æ¥çš„äº‹æƒ…å°±æ˜¯åŠ è½½ä¸»æ¨¡å— `loader.js` äº†ï¼Œå‰©ä¸‹çš„å°±éƒ½æ˜¯ `vscode` æœ¬èº«çš„æ´»äº†;

æ­¤æ—¶ `code-server` çš„ä¸»è¦ä»»åŠ¡ä¹Ÿå®Œæˆäº†

![5.png](../assets/img/14/5.png)